#!/usr/bin/env ruby
#  Phusion Passenger - http://www.modrails.com/
#  Copyright (c) 2009 Phusion
#
#  "Phusion Passenger" is a trademark of Hongli Lai & Ninh Bui.
#
#  See LICENSE file for license information.
require 'timeout'
require 'tempfile'

ANALYSIS_TIMEOUT = 10

# ANSI color codes
RESET   = "\e[0m"
BOLD    = "\e[1m"
RED     = "\e[31m"
YELLOW  = "\e[33m"
BLUE_BG = "\e[44m"

def start
	if ARGV.size < 1
		usage
		exit 1
	end
	
	pid = Integer(ARGV[0])
	puts "Retrieving backtrace for PID #{pid}. Please wait at least #{ANALYSIS_TIMEOUT} seconds..."
	delete_existing_backtrace_file(pid)
	signal_process_to_print_backtrace(pid)
	puts
	backtrace = print_and_delete_backtrace_file(pid)
	if backtrace
		puts "#{BLUE_BG}#{YELLOW}#{BOLD}Backtrace information:#{RESET}"
		
		# Get rid of the process ID header bar.
		backtrace.sub!(/^===.*?\n/, '')
		# Highlight the thread section headers.
		backtrace.gsub!(/^# (.*)$/, "#{BOLD}# \\1#{RESET}")
		puts backtrace
	else
		puts "#{BLUE_BG}#{YELLOW}#{BOLD}Notice:#{RESET}"
		puts "Application on PID #{pid} is frozen inside a #{YELLOW}#{BOLD}native (non-Ruby) function#{RESET}."
		puts
		puts "Retrieving the native backtrace, please wait..."
		backtrace = generate_native_backtrace(pid)
		puts
		puts "#{BLUE_BG}#{YELLOW}#{BOLD}Backtrace information:#{RESET}"
		puts backtrace
	end
end

def delete_existing_backtrace_file(pid)
	Dir["/tmp/passenger.*/backend_ruby_backtrace.#{pid}.txt"].each do |filename|
		File.unlink(filename) rescue nil
	end
end

def signal_process_to_print_backtrace(pid)
	Process.kill('SIGQUIT', pid)
rescue Errno::ESRCH
	puts "PID #{pid} does not exist."
	exit 2
end

def print_and_delete_backtrace_file(pid)
	Timeout.timeout(ANALYSIS_TIMEOUT) do
		while true
			matches = Dir["/tmp/passenger.*/backend_ruby_backtrace.#{pid}.txt"]
			if matches.empty?
				sleep 0.33
			else
				data = File.read(matches.first)
				File.unlink(matches.first) rescue nil
				return data
			end
		end
	end
rescue Timeout::Error
	return false
end

def generate_native_backtrace(pid)
	Tempfile.open('passenger-gdb') do |tempfile|
		tempfile.puts("attach #{pid}")
		tempfile.puts("thread apply all bt")
		tempfile.close
		result = `gdb -n -batch -x "#{tempfile.path}" < /dev/null`
		if $?.exitstatus != 0
			STDERR.write("\nCould not generate a backtrace.")
			exit 3
		else
			return result
		end
	end
end

def usage
	puts "Usage: passenger-show-backtrace <PID>"
	puts
	puts "Shows the backtrace of the Rails/Rack application on the given PID."
end

start
