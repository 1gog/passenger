#!/usr/bin/env ruby
#  Phusion Passenger - https://www.phusionpassenger.com/
#  Copyright (c) 2013 Phusion
#
#  "Phusion Passenger" is a trademark of Hongli Lai & Ninh Bui.
#
#  See LICENSE file for license information.

source_root = File.expand_path("..", File.dirname(__FILE__))
$LOAD_PATH.unshift("#{source_root}/lib")
require 'phusion_passenger'
PhusionPassenger.locate_directories

require 'optparse'
require 'socket'
require 'logger'
require 'phusion_passenger/constants'
require 'phusion_passenger/message_channel'
require 'phusion_passenger/message_client'
require 'phusion_passenger/platform_info/ruby'


module PhusionPassenger

class FlyingPassenger
	class Error < StandardError
	end

	class RubyUnsupported < Error
	end

	class SpawnError < Error
	end

	class OptionError < Error
	end

	class Exit < StandardError
		attr_reader :code

		def initialize(code)
			@code = code
		end
	end

	attr_reader :logger

	def initialize(argv)
		check_ruby_compatibility
		@argv = argv.dup
	end

	def start
		parse_options
		initialize_logger
		maybe_daemonize
		maybe_write_pidfile
		spawn
		@logger.info("Flying Passenger up and listening on #{@watchdog_options[:request_socket_link]}!")
		return nil
	rescue Exit => e
		return e.code
	rescue
		maybe_cleanup_pidfile
		raise
	end

	def wait
		return wait_for_exit
	ensure
		maybe_cleanup_pidfile
		@logger.info("Flying Passenger exited")
	end

private
	def check_ruby_compatibility
		if !Process.respond_to?(:spawn)
			if Process.euid == 0
				sudo = "sudo "
				rvmsudo = "#{PlatformInfo.ruby_sudo_command} "
			end
			raise RubyUnsupported, "The Flying Passenger program must be run on Ruby 1.9. " +
				"It's currently being run on Ruby #{RUBY_VERSION} (#{PlatformInfo.ruby_command}). " +
				"Please restart it using Ruby 1.9, like this:\n\n" +
				"  #{sudo}ruby1.9 #{PhusionPassenger.bin_dir}/flying-passenger\n\n" +
				"If you installed Ruby 1.9 with RVM then you can use rvm-exec to invoke Ruby 1.9, like this:\n\n" +
				"  #{rvmsudo}rvm-exec ruby-1.9.3 #{PhusionPassenger.bin_dir}/flying-passenger"
		end
	end

	def parse_options
		@watchdog_options = {
			:log_level => DEFAULT_LOG_LEVEL,
			:max_pool_size => DEFAULT_MAX_POOL_SIZE,
			:pool_idle_time => DEFAULT_POOL_IDLE_TIME
		}
		@options = {}
		parser = OptionParser.new do |opts|
			nl = "\n#{' ' * 37}"
			opts.banner = "Usage: flying-passenger [options]"
			opts.separator ""
			
			opts.separator "Options:"
			opts.on("--socket-file FILENAME", String, "The socket to listen on") do |val|
				@watchdog_options[:request_socket_link] = val
			end
			opts.on("--daemonize", "Daemonize into background") do
				@options[:daemonize] = true
			end
			opts.on("--pid-file FILENAME", String, "Write to the given PID file") do |val|
				@options[:pidfile] = val
			end
			opts.on("--log-file FILENAME", String, "The log file to use") do |val|
				@options[:log_file] = val
				@watchdog_options[:debug_log_file] = val
			end
			opts.on("--log-level LEVEL", Integer, "The log level (default: #{@watchdog_options[:log_level]})") do |val|
				@watchdog_options[:log_level] = val
			end
			opts.on("--max-pool-size NUMBER", Integer, "Max total number of processes (default: #{@watchdog_options[:max_pool_size]})") do |val|
				@watchdog_options[:max_pool_size] = val
			end
			opts.on("--pool-idle-time SECONDS", Integer, "Max process idle time (default: #{@watchdog_options[:pool_idle_time]})") do |val|
				@watchdog_options[:pool_idle_time] = val
			end
			opts.on("--max-preloader-idle-time", Integer, "Max preloader idle time") do |val|
				@watchdog_options[:max_preloader_idle_time] = val
			end
			opts.on("--temp-dir PATH", String, "Directory to store the server instance dir in") do |val|
				@watchdog_options[:temp_dir] = val
			end
			opts.on("--help", "Show this help message") do
				@options[:help] = true
			end
		end
		begin
			parser.parse!
		rescue OptionParser::ParseError => e
			STDERR.puts e
			STDERR.puts
			STDERR.puts "Please see '--help' for valid options."
			exit 1
		end

		if @options[:help]
			puts parser
			exit 0
		end

		if !@watchdog_options[:request_socket_link]
			STDERR.puts "You didn't specify a socket filename. Please set --socket-file."
			exit 1
		end
		if @options[:daemonize] && !PlatformInfo.ruby_supports_fork?
			raise Error, "Unable to daemonize using the current Ruby interpreter " +
				"(#{PlatformInfo.ruby_command}) because it does not support forking."
		end
		if @options[:daemonize] && !@options[:log_file]
			raise Error, "If you set --daemonize then you must also set --log-file."
		end
	end

	def initialize_logger
		if @options[:log_file]
			file = File.open(@options[:log_file], "a")
			@logger = Logger.new(file)
			STDOUT.reopen(file)
			STDERR.reopen(file)
			STDOUT.sync = STDERR.sync = file.sync = true
		else
			@logger = Logger.new(STDERR)
		end
		if @watchdog_options[:log_level] <= 0
			@logger.level = Logger::INFO
		else
			@logger.level = Logger::DEBUG
		end
		@logger.info("Welcome to Flying Passenger #{PhusionPassenger::VERSION_STRING}")
	end

	def create_arguments
		args = {
			"web_server_type" => "nginx",
			"web_server_pid" => $$.to_s,
			"passenger_root" => PhusionPassenger.source_root,
			"ruby" => PlatformInfo.ruby_command,
			"setsid" => "true",
			"request_socket_password" => "-"
		}
		@watchdog_options.each_pair do |name, val|
			args[name.to_s] = val.to_s
		end
		return args.to_a.flatten
	end

	def spawn
		args = ["#{PhusionPassenger.agents_dir}/PassengerWatchdog"]
		#args.concat(create_arguments)

		@logger.info("Starting PassengerWatchdog...")
		a, b = UNIXSocket.pair
		channel = MessageChannel.new(a)
		args << {
			:in  => ['/dev/null', 'r'],
			:out => :out,
			:err => :err,
			3    => b,
			:close_others => true
		}

		begin
			pid = Process.spawn(*args)
		rescue SystemCallError => e
			raise SpawnError, e.message
		end
		b.close
		@logger.info("PassengerWatchdog started on PID #{pid}")
		
		@logger.debug { "Sending arguments to PassengerWatchdog: " + create_arguments.inspect }
		channel.write("VariantMap", *create_arguments)
		result = channel.read
		result_name, *result_args = result
		@logger.debug { "PassengerWatchdog response: " + result.inspect }

		case result_name
		when "Agents information"
			@logger.info("PassengerWatchdog initialized properly")
		when "Watchdog startup error"
			raise SpawnError, "Unable to start the Phusion Passenger watchdog " +
				"because it encountered the following error during startup: " +
				result_args[0]
		else
			a.close
			raise SpawnError, "The Phusion Passenger watchdog sent an unknown feedback message: " +
				result.inspect
		end

		@pid  = pid
		@pipe = a
		@info = Hash[*result_args]
	rescue
		a.close if a && !a.closed?
		b.close if b && !b.closed?
		raise
	end

	def maybe_daemonize
		if @options[:daemonize]
			@logger.info("Daemonization requested...")
			pid = fork
			if pid
				# Parent
				exit!(0)
			else
				# Child
				trap "HUP", "IGNORE"
				STDIN.reopen("/dev/null", "r")
				STDOUT.reopen(@options[:log_file], "a")
				STDERR.reopen(@options[:log_file], "a")
				STDOUT.sync = true
				STDERR.sync = true
				Process.setsid
				@logger.info("Daemonized into background: PID #{$$}")
			end
		end
	end

	def maybe_write_pidfile
		if @options[:pidfile]
			@logger.info("Creating PID file: #{@options[:pidfile]}")
			if File.exist?(@options[:pidfile])
				raise Error, "PID file already exists! Exiting!"
			else
				File.open(@options[:pidfile], "w") do |f|
					f.puts $$
				end
			end
		end
	end

	def maybe_cleanup_pidfile
		if @options[:pidfile] && File.exist?(@options[:pidfile])
			@logger.info("Deleting PID file: #{@options[:pidfile]}")
			File.unlink(@options[:pidfile])
		end
	end

	def async_waitpid(pid)
		a, b = IO.pipe
		thread = Thread.new do
			Thread.current.abort_on_exception = true
			begin
				Process.waitpid(pid)
				Thread.current[:result] = $?
			ensure
				b.close
			end
		end
		return [a, thread]
	end

	def gracefully_shut_down_agent(address, username, password)
		client = MessageClient.new(username, password, address)
		client.write("exit")
		result = client.read
		if result && result[0] == "Passed security"
			result = client.read
			return result[0] == "exit command received"
		else
			return false
		end
	rescue SystemCallError, IOError
		return false
	end

	def send_shutdown_signal
		@logger.info("Performing clean shutdown")
		clean_shutdown = gracefully_shut_down_agent(
			@info["helper_agent_admin_socket_address"],
			"_web_server",
			@info["helper_agent_exit_password"])
		clean_shutdown = clean_shutdown &&
			gracefully_shut_down_agent(
				@info["logging_socket_address"],
				"logging",
				@info["logging_socket_password"])
		
		begin
			@pipe.write_nonblock(clean_shutdown ? 'c' : 'u')
			@pipe.close
		rescue Errno::EAGAIN, Errno::EPIPE, Errno::ECONNRESET
			# Ignore error, we don't care.
		end
		
		@sent_shutdown_signal = true
	end

	def wait_for_exit
		exit_signaller, waitpid_thread = async_waitpid(@pid)

		begin
			select([exit_signaller])
		rescue SignalException => e
			@logger.info("Received signal #{e.signo}")
			if e.signo == Signal.list["INT"] || e.signo == Signal.list["TERM"]
				send_shutdown_signal if !@sent_shutdown_signal
			else
				Process.kill(e.signo, @pid) rescue nil
			end
			retry
		end

		exit_signaller.close
		waitpid_thread.join
		result = waitpid_thread[:result]
		return result ? (result.exitstatus || 1) : 1
	ensure
		@pipe.close if !@pipe.closed?
		@pipe = nil
		@pid = nil
	end

	def exit(code = 0)
		raise Exit.new(code)
	end
end

end # module PhusionPassenger

begin
	flyer = PhusionPassenger::FlyingPassenger.new(ARGV)
	exit_code = flyer.start
	exit(exit_code) if exit_code
	exit(flyer.wait)
rescue PhusionPassenger::FlyingPassenger::Error => e
	if flyer && flyer.logger
		flyer.logger.fatal(e.message)
	else
		abort(e.message)
	end
end
