#!/usr/bin/env ruby
#  Phusion Passenger - http://www.modrails.com/
#  Copyright (c) 2009 Phusion
#
#  "Phusion Passenger" is a trademark of Hongli Lai & Ninh Bui.
#
#  Permission is hereby granted, free of charge, to any person obtaining a copy
#  of this software and associated documentation files (the "Software"), to deal
#  in the Software without restriction, including without limitation the rights
#  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
#  copies of the Software, and to permit persons to whom the Software is
#  furnished to do so, subject to the following conditions:
#
#  The above copyright notice and this permission notice shall be included in
#  all copies or substantial portions of the Software.
#
#  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
#  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
#  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
#  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
#  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
#  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
#  THE SOFTWARE.

PASSENGER_ROOT = File.expand_path(File.dirname(__FILE__) << "/..")
$LOAD_PATH.unshift("#{PASSENGER_ROOT}/lib")
require 'rubygems' rescue nil
require 'optparse'
require 'socket'
require 'thread'
require 'fileutils'
require 'erb'
require 'phusion_passenger/constants'
require 'phusion_passenger/packaging'
require 'phusion_passenger/abstract_installer'

begin
	require 'daemon_controller'
	begin
		require 'daemon_controller/version'
	rescue LoadError
		STDERR.puts "*** Your version of daemon_controller is too old. You must install 0.2.3 or later. Please upgrade:"
		STDERR.puts
		STDERR.puts " sudo gem uninstall FooBarWidget-daemon_controller"
		STDERR.puts " sudo gem install daemon_controller"
		exit 1
	end
rescue LoadError
	STDERR.puts "*** Please install daemon_controller first: sudo gem install daemon_controller"
	exit 1
end
begin
	require 'file/tail'
rescue LoadError
	STDERR.puts "*** Please install file-tail first: sudo gem install file-tail"
	exit 1
end

module PhusionPassenger

class Multicorn
	def self.run_command(argv)
		new.run_command(argv)
	end
	
	def initialize
		@options = {}
		@console_mutex = Mutex.new
	end
	
	def run_command(argv)
		command = argv[0]
		if command.nil? || command == '-h' || command == '--help'
			command_help
			exit
		elsif command == '-v' || command == '--version'
			command_version
			exit
		elsif respond_to?("command_#{command}", true)
			@args = argv[1..-1]
			@original_args = @args.dup
			begin
				send("command_#{command}")
			rescue OptionParser::ParseError => e
				puts e
				puts
				puts "Please see '--help' for valid options."
				exit 1
			end
		else
			STDERR.puts "Unknown command '#{command}'. Please type --help for options."
			exit 1
		end
	end

private
	#### Commands ####
	
	def command_start
		description = "Starts Multicorn in order to serve a Ruby web application."
		@options = {
			:address       => '0.0.0.0',
			:port          => 3000,
			:env           => ENV['RAILS_ENV'] || ENV['RACK_ENV'] || 'development',
			:nginx_version => '0.7.63'
		}
		parse_options!("start [directory]", description) do |opts|
			opts.on("-a", "--address HOST", String,
				wrap_desc("Bind to HOST address (default: #{@options[:address]})")) do |value|
				@options[:address] = value
				@options[:tcp] = true
			end
			opts.on("-p", "--port NUMBER", Integer,
				wrap_desc("Use the given port number (default: #{@options[:port]})")) do |value|
				@options[:port] = value
				@options[:tcp] = true
			end
			opts.on("-S", "--socket FILE", String,
				wrap_desc("Bind to Unix domain socket instead of TCP socket")) do |value|
				@options[:socket_file] = value
			end
			opts.on("-e", "--environment ENV", String,
				wrap_desc("Framework environment (default: #{@options[:env]})")) do |value|
				@options[:port] = value
			end
			opts.on("-d", "--daemonize",
				wrap_desc("Daemonize into the background")) do
				@options[:daemonize] = true
			end
			opts.on("--user USERNAME", String,
				wrap_desc("User to run as. Ignored unless running as root.")) do |value|
				@options[:user] = value
			end
		end
		if @options[:tcp] && @options[:socket_file]
			STDERR.puts "You cannot specify both --address/--port and --socket. Please choose either one."
			exit 1
		end
		
		check_port_and_display_sudo_suggestion
		ensure_nginx_installed
		determine_various_resource_locations
		determine_apps_to_serve
		
		create_nginx_controller
		begin
			@nginx.start
		rescue DaemonController::AlreadyStarted
			begin
				pid = @nginx.pid
			rescue SystemCallError, IOError
				pid = nil
			end
			if pid
				STDERR.puts "*** ERROR: Multicorn is already running on PID #{pid}."
			else
				STDERR.puts "*** ERROR: Multicorn is already running."
			end
			exit 1
		rescue DaemonController::StartError => e
			STDERR.puts "*** ERROR: could not start Multicorn Nginx core:"
			STDERR.puts e
			exit 1
		ensure
			File.unlink(@config_filename) rescue nil
		end
		
		puts "=============== Multicorn web server started ==============="
		puts "PID file: #{@options[:pid_file]}"
		puts "Log file: #{@options[:log_file]}"
		if @apps.size > 1
			puts
			if @options[:socket_file]
				puts "Serving these applications:"
			else
				puts "Serving these applications on #{@options[:address]} port #{@options[:port]}:"
			end
			puts " Host name                     Directory"
			puts "------------------------------------------------------------"
			@apps.each do |app|
				printf " %-26s    %s\n", app[:server_names][0], app[:root]
			end
		else
			puts "Accessible via: #{listen_url}"
		end
		puts
		if @options[:daemonize]
			puts "Serving in the background as a daemon."
		else
			puts "You can stop Multicorn by pressing Ctrl-C."
		end
		puts "============================================================"
		
		daemonize if @options[:daemonize]
		watch_directories_in_background if @apps.size > 1
		watch_log_files_in_background if !@options[:daemonize]
		begin
			wait_until_nginx_has_exited
		rescue Interrupt
			stop_nginx
			exit 2
		rescue SignalException => signal
			stop_nginx
			if signal.message == 'SIGINT' || signal.message == 'SIGTERM'
				exit 2
			else
				raise
			end
		rescue Exception => e
			stop_nginx
			raise
		end
	end
	
	def command_stop
		determine_various_resource_locations(false)
		create_nginx_controller
		begin
			running = @nginx.running?
		rescue SystemCallError, IOError
			running = false
		end
		if running
			@nginx.stop
		else
			STDERR.puts "According to the PID file '#{@options[:pid_file]}', Multicorn doesn't seem to be running."
			STDERR.puts
			STDERR.puts "If you know that Multicorn is running then you've probably specified the wrong PID " <<
				"file. In that case, please specify the right one with --pid-file."
			exit 1
		end
	end
	
	def command_status
		determine_various_resource_locations(false)
		create_nginx_controller
		begin
			running = @nginx.running?
			pid = @nginx.pid
		rescue SystemCallError, IOError
			running = false
		end
		if running
			puts "Multicorn is running on PID #{pid}."
		else
			puts "Multicorn is not running."
		end
	end
	
	def command_help
		puts "Available commands:"
		puts
		puts "  multicorn start       Start Multicorn."
		puts "  multicorn stop        Stop a running Multicorn instance."
		puts "  multicorn status      Show the status of a running Multicorn instance."
		puts
		puts "Special options:"
		puts
		puts "  multicorn --help      Display this help message."
		puts "  multicorn --version   Display version number."
		puts
		puts "For more information about a specific command, please type 'multicorn <COMMAND> --help', e.g. 'multicorn start --help'."
	end
	
	def command_version
		require 'phusion_passenger/constants'
		puts "Phusion Passenger version #{VERSION_STRING}"
		puts
		puts '"Phusion Passenger" is a trademark of Hongli Lai & Ninh Bui.'
	end
	
	
	#### Helper methods ####
	
	def parse_options!(command_name, description = nil)
		help = false
		parser = OptionParser.new do |opts|
			opts.banner = "Usage: multicorn #{command_name} [options]"
			opts.separator description if description
			opts.separator " "
			opts.separator "Options:"
			yield opts
			opts.on("-h", "--help", "Show this help message") do
				help = true
			end
		end
		parser.parse!(@args)
		if help
			puts parser
			exit 0
		end
	end
	
	# Word wrap the given option description text so that it is formatted
	# nicely in the --help output.
	def wrap_desc(description_text)
		line_prefix = "\n" << (' ' * 37)
		col = 43
		result = description_text.gsub(/(.{1,#{col}})( +|$\n?)|(.{1,#{col}})/, "\\1\\3#{line_prefix}")
		result.strip!
		return result
	end
	
	# Most platforms don't allow non-root processes to bind to a port lower than 1024.
	# Check whether this is the case for the current platform and if so, tell the user
	# that it must re-run Multicorn with sudo.
	def check_port_and_display_sudo_suggestion
		if !@options[:socket_file] && @options[:port] < 1024 && Process.euid != 0
			begin
				TCPServer.new('127.0.0.1', @options[:port]).close
			rescue Errno::EACCES
				myself = `whoami`.strip
				STDERR.puts "Only the 'root' user can run Multicorn on port #{@options[:port]}. You are currently running"
				STDERR.puts "as '#{myself}'. Please re-run Multicorn with root privileges with the"
				STDERR.puts "following command:"
				STDERR.puts
				STDERR.puts "  sudo multicorn start #{@original_args.join(' ')} --user=#{myself}"
				STDERR.puts
				STDERR.puts "Don't forget the '--user' part! That will make Multicorn drop root privileges"
				STDERR.puts "and switch to '#{myself}' after it has obtained port #{@options[:port]}."
				exit 1
			end
		end
	end
	
	def listen_url
		if @options[:socket_file]
			return @options[:socket_file]
		else
			result = "http://#{@options[:address]}"
			if @options[:port] != 80
				result << ":#{@options[:port]}"
			end
			result << "/"
			return result
		end
	end
	
	def nginx_listen_address
		if @options[:socket_file]
			return "unix:" + File.expand_path(@options[:socket_file])
		else
			return "#{@options[:address]}:#{@options[:port]}"
		end
	end
	
	def looks_like_app_directory?(dir)
		return File.exist?("#{dir}/config/environment.rb") ||
			File.exist?("#{dir}/config.ru") ||
			File.exist?("#{dir}/passenger_wsgi.py")
	end
	
	def nginx_install_directory
		multicorn_dir = "/var/lib/multicorn/#{VERSION_STRING}"
		if File.directory?(global_dir)
			return global_dir
		else
			if Process.euid == 0
			end
			private_dir = "#{home}/.multicorn/#{VERSION_STRING}/nginx-#{@options[:nginx_version]}"
		end
		if Process.euid == 0
			return 
		else
			home = ENV['HOME']
			return 
		end
	end
	
	def install_nginx(multicorn_dir, nginx_dir, version)
		NginxInstaller.new(:multicorn_dir => multicorn_dir,
			:nginx_dir => nginx_dir,
			:version => version).start
	end
	
	def ensure_nginx_installed
		home           = ENV['HOME']
		nginx_version  = @options[:nginx_version]
		@multicorn_dir = "/var/lib/multicorn/#{VERSION_STRING}"
		@nginx_dir     = "#{@multicorn_dir}/nginx-#{nginx_version}"
		if !File.exist?("#{@nginx_dir}/sbin/nginx")
			if Process.euid == 0
				install_nginx(@multicorn_dir, @nginx_dir, nginx_version)
			else
				@multicorn_dir = "#{home}/.multicorn/#{VERSION_STRING}"
				@nginx_dir     = "#{@multicorn_dir}/nginx-#{nginx_version}"
				if !File.exist?("#{@nginx_dir}/sbin/nginx")
					install_nginx(@multicorn_dir, @nginx_dir, nginx_version)
				end
			end
		end
		
		@temp_dir = "#{home}/.multicorn/#{VERSION_STRING}/nginx-#{nginx_version}/temp"
		ensure_directory_exists(@temp_dir)
	end
	
	def filename_to_server_names(filename)
		basename = File.basename(filename)
		names = [basename]
		if basename !~ /^www\.$/i
			names << "www.#{basename}"
		end
		return names
	end
	
	def ensure_directory_exists(dir)
		if !File.exist?(dir)
			FileUtils.mkdir_p(dir)
		end
	end
	
	def determine_various_resource_locations(create_subdirs = true)
		if @args.empty?
			if looks_like_app_directory?(".")
				@options[:pid_file] ||= File.expand_path("tmp/pids/multicorn.pid")
				@options[:log_file] ||= File.expand_path("log/multicorn.log")
				if create_subdirs
					ensure_directory_exists(File.dirname(@options[:pid_file]))
					ensure_directory_exists(File.dirname(@options[:log_file]))
				end
			else
				@options[:pid_file] ||= File.expand_path("multicorn.pid")
				@options[:log_file] ||= File.expand_path("multicorn.log")
			end
		else
			@options[:pid_file] ||= File.expand_path(File.join(@args[0], "multicorn.pid"))
			@options[:log_file] ||= File.expand_path(File.join(@args[0], "multicorn.log"))
		end
	end
	
	def determine_apps_to_serve
		@apps = []
		if @args.empty?
			if looks_like_app_directory?(".")
				@apps << {
					:server_names => ["_"],
					:root => File.expand_path(".")
				}
			else
				Dir["./*"].each do |entry|
					if looks_like_app_directory?(entry)
						server_names = filename_to_server_names(entry)
						@apps << {
							:server_names => server_names,
							:root => File.expand_path(entry)
						}
					end
				end
			end
		else
			@args.each do |arg|
				if looks_like_app_directory?(arg)
					server_names = filename_to_server_names(arg)
					@apps << {
						:server_names => server_names,
						:root => File.expand_path(arg)
					}
				else
					Dir["#{arg}/*"].each do |entry|
						if looks_like_app_directory?(entry)
							server_names = filename_to_server_names(entry)
							@apps << {
								:server_names => server_names,
								:root => File.expand_path(entry)
							}
						end
					end
				end
			end
		end
	end
	
	def create_nginx_config_file
		File.open(@config_filename, 'w') do |f|
			f.chmod(0644)
			template_filename = File.join(LIBDIR, "phusion_passenger", "templates", "multicorn", "config.erb")
			erb = ERB.new(File.read(template_filename))
			output = erb.result(binding)
			f.write(output)
			puts output if ENV['DEBUG_MULTICORN']
		end
	end
	
	def default_group_for(username)
		require 'etc' unless defined?(Etc)
		user = Etc.getpwnam(username)
		group = Etc.getgrgid(user.gid)
		return group.name
	end
	
	def determine_nginx_start_command
		return "#{@nginx_dir}/sbin/nginx -c '#{@config_filename}'"
	end
	
	def ping_nginx
		if @options[:socket_file]
			UNIXSocket.new(@options[:socket_file])
		else
			TCPSocket.new(@options[:address], @options[:port])
		end
	end
	
	def create_nginx_controller
		@config_filename = "/tmp/multicorn.#{$$}.conf"
		@nginx = DaemonController.new(
			:identifier    => 'Nginx',
			:before_start  => method(:create_nginx_config_file),
			:start_command => method(:determine_nginx_start_command),
			:ping_command  => method(:ping_nginx),
			:pid_file      => @options[:pid_file],
			:log_file      => @options[:log_file],
			:timeout       => 25
		)
		@nginx_mutex = Mutex.new
	end
	
	def daemonize
		pid = fork
		if pid
			# Parent
			exit!
		else
			# Child
			trap "HUP", "IGNORE"
			STDIN.reopen("/dev/null", "r")
			STDOUT.reopen(@options[:log_file], "a")
			STDERR.reopen(@options[:log_file], "a")
			STDOUT.sync = true
			STDERR.sync = true
			Process.setsid
		end
	end
	
	def directory_mtimes
		if @args.empty?
			dirs = ["."]
		else
			dirs = @args.sort
		end
		dirs.map! do |dir|
			File.stat(dir).mtime
		end
		return dirs
	end
	
	def watch_directories
		old_mtimes = directory_mtimes
		while true
			sleep 3
			new_mtimes = directory_mtimes
			if old_mtimes != new_mtimes
				old_mtimes = new_mtimes
				yield
			end
		end
	end
	
	def watch_directories_in_background
		Thread.new do
			watch_directories do
				puts "*** #{Time.now}: redeploying applications ***"
				determine_apps_to_serve
				begin
					pid = @nginx.pid
				rescue SystemCallError, IOError
					STDERR.puts "*** Error: unable to retrieve the web server's PID."
					next
				end
				create_nginx_config_file
				begin
					Process.kill('HUP', pid) rescue nil
					
					@console_mutex.synchronize do
						puts "Now serving these applications:"
						puts " Host name                     Directory"
						puts "------------------------------------------------------------"
						@apps.each do |app|
							printf " %-26s    %s\n", app[:server_names][0], app[:root]
						end
						puts "------------------------------------------------------------"
					end
					
					# Wait a short period for Nginx to reload its config
					# before deleting the config file.
					sleep 3
				ensure
					File.unlink(@config_filename) rescue nil
				end
			end
		end
	end
	
	def watch_log_file(log_file)
		if File.exist?(log_file)
			backward = 0
		else
			# File::Tail bails out if the file doesn't exist, so wait until it exists.
			while !File.exist?(log_file)
				sleep 1
			end
			backward = 10
		end
		
		File::Tail::Logfile.open(log_file, :backward => backward) do |log|
			log.interval = 0.1
			log.max_interval = 1
			log.tail do |line|
				@console_mutex.synchronize do
					STDOUT.write(line)
					STDOUT.flush
				end
			end
		end
	end
	
	def watch_log_files_in_background
		@apps.each do |app|
			Thread.new do
				watch_log_file("#{app[:root]}/log/#{@options[:env]}.log")
			end
		end
	end
	
	def wait_until_nginx_has_exited
		# Since Nginx is not our child process (it daemonizes or we daemonize)
		# we cannot use Process.waitpid to wait for it. A busy-sleep-loop with
		# Process.kill(0, pid) isn't very efficient. Instead we do this:
		#
		# Connect to Nginx and wait until Nginx disconnects the socket because of
		# timeout. Keep doing this until we can no longer connect.
		while true
			if @options[:socket_file]
				socket = UNIXSocket.new(@options[:socket_file])
			else
				socket = TCPSocket.new(@options[:address], @options[:port])
			end
			begin
				socket.read rescue nil
			ensure
				socket.close rescue nil
			end
		end
	rescue Errno::ECONNREFUSED, Errno::ECONNRESET
	end
	
	def stop_nginx
		@nginx_mutex.synchronize do
			STDOUT.write("Stopping web server...")
			STDOUT.flush
			@nginx.stop
			STDOUT.puts " done"
			STDOUT.flush
		end
	end
end

class NginxInstaller < AbstractInstaller
	def dependencies
		result = [
			Dependencies::GCC,
			Dependencies::Make,
			Dependencies::DownloadTool,
			Dependencies::Ruby_DevHeaders,
			Dependencies::Ruby_OpenSSL,
			Dependencies::RubyGems,
			Dependencies::Rake,
			Dependencies::Zlib_Dev
		]
		if Dependencies.fastthread_required?
			result << Dependencies::FastThread
		end
		return result
	end
	
	def install!
		require 'fileutils'
		require 'phusion_passenger/platform_info'
		require 'phusion_passenger/dependencies'
		
		show_welcome_screen
		check_dependencies(false) || exit(1)
		puts
		check_whether_we_can_write_to(@nginx_dir) || exit(1)
		
		source_dir = download_and_extract_nginx do |progress, total|
			show_progress(progress, total, 1, 7, "Extracting...")
		end
		if source_dir.nil?
			puts
			show_possible_solutions_for_download_and_extraction_problems
			exit(1)
		end
		compile_passenger_support_files do |progress, total, phase, status_text|
			if phase == 1
				show_progress(progress, total, 2, 7, status_text)
			else
				show_progress(progress, total, 3..5, 7, status_text)
			end
		end
		install_nginx(source_dir) do |progress, total, status_text|
			show_progress(progress, total, 6..7, 7, status_text)
		end
		puts
		color_puts "<green><b>All done!</b></green>"
		puts
	end

private
	def show_welcome_screen
		render_template 'multicorn/welcome',
			:version => @version,
			:dir => @nginx_dir
		puts
	end
	
	def check_whether_we_can_write_to(dir)
		FileUtils.mkdir_p(dir)
		File.new("#{dir}/__test__.txt", "w").close
		return true
	rescue
		new_screen
		if Process.uid == 0
			render_template 'multicorn/cannot_write_to_dir', :dir => dir
		else
			render_template 'multicorn/run_installer_as_root', :dir => dir
		end
		return false
	ensure
		File.unlink("#{dir}/__test__.txt") rescue nil
	end
	
	def show_progress(progress, total, phase, total_phases, status_text = "")
		if !phase.is_a?(Range)
			phase = phase..phase
		end
		total_progress = (phase.first - 1).to_f / total_phases
		total_progress += (progress.to_f / total) * ((phase.last - phase.first + 1).to_f / total_phases)
		
		max_width = 79
		progress_bar_width = 45
		text = sprintf("[%-#{progress_bar_width}s] %s",
			'*' * (progress_bar_width * total_progress).to_i,
			status_text)
		text = text.ljust(max_width)
		text = text[0 .. max_width - 1]
		STDOUT.write("#{text}\r")
		STDOUT.flush
	end
	
	def download_and_extract_nginx
		color_puts "<banner>Downloading Nginx...</banner>"
		
		myself     = `whoami`.strip
		basename   = "#{myself}-nginx-#{@version}.tar.gz"
		original_output_dir = "/tmp/nginx-#{@version}"
		output_dir = "/tmp/#{myself}-nginx-#{@version}"
		#File.unlink("/tmp/#{basename}") rescue nil
		FileUtils.rm_rf(original_output_dir)
		FileUtils.rm_rf(output_dir)
		
		if false && !download("http://sysoev.ru/nginx/nginx-#{@version}.tar.gz", "/tmp/#{basename}")
			return nil
		end
		Dir.chdir("/tmp") do
			color_puts "<banner>Installing Nginx core...</banner>"
			File.open(basename) do |f|
				IO.popen("tar xzf -", "w") do |io|
					buffer = ''
					total_size = File.size(basename)
					bytes_read = 0
					yield(bytes_read, total_size)
					begin
						while !f.eof?
							f.read(1024 * 8, buffer)
							io.write(buffer)
							io.flush
							bytes_read += buffer.size
							yield(bytes_read, total_size)
						end
					rescue Errno::EPIPE
						return nil
					end
				end
				if $?.exitstatus != 0
					return nil
				end
			end
			File.rename(original_output_dir, output_dir)
			return output_dir
		end
	rescue Interrupt
		exit 2
	end
	
	def show_possible_solutions_for_download_and_extraction_problems
		new_screen
		render_template "multicorn/possible_solutions_for_download_and_extraction_problems"
		puts
	end
	
	def run_command_with_throbber(command, status_text)
		backlog = ""
		IO.popen("#{command} 2>&1", "r") do |io|
			throbbers = ['-', '\\', '|', '/']
			index = 0
			while !io.eof?
				backlog << io.readline
				yield("#{status_text} #{throbbers[index]}")
				index = (index + 1) % throbbers.size
			end
		end
		if $?.exitstatus != 0
			STDERR.puts
			STDERR.puts backlog
			STDERR.puts "*** ERROR: command failed: #{command}"
			exit 1
		end
	end
	
	def copy_files(files, target)
		FileUtils.mkdir_p(target)
		files.each_with_index do |filename, i|
			next if File.directory?(filename)
			dir = "#{target}/#{File.dirname(filename)}"
			if !File.directory?(dir)
				FileUtils.mkdir_p(dir)
			end
			FileUtils.install(filename, "#{target}/#{filename}")
			yield(i + 1, files.size)
		end
	end
	
	def run_rake_task!(target)
		rake = "#{PlatformInfo::RUBY} #{PlatformInfo.rake}"
		total_lines = `#{rake} #{target} --dry-run`.split("\n").size - 1
		backlog = ""
		
		IO.popen("#{rake} #{target} --trace STDERR_TO_STDOUT=1", "r") do |io|
			progress = 1
			while !io.eof?
				line = io.readline
				if line =~ /^\*\* /
					yield(progress, total_lines)
					backlog.replace("")
					progress += 1
				else
					backlog << line
				end
			end
		end
		if $?.exitstatus != 0
			STDERR.puts
			STDERR.puts "*** ERROR: the following command failed:"
			STDERR.puts(backlog)
			exit 1
		end
	end
	
	def compile_passenger_support_files
		myself = `whoami`.strip
		rake = "#{PlatformInfo::RUBY} #{PlatformInfo.rake}"
		
		# Copy Phusion Passenger sources to designated directory.
		yield(0, 1, 1, "Preparing Phusion Passenger...")
		FileUtils.rm_rf(@multicorn_dir)
		Dir.chdir(PASSENGER_ROOT) do
			files = `#{rake} package:filelist --silent`.split("\n")
			copy_files(files, @multicorn_dir) do |progress, total|
				yield(progress, total, 1, "Copying files...")
			end
		end
		
		# Then compile it.
		yield(0, 1, 2, "Preparing Phusion Passenger...")
		Dir.chdir(@multicorn_dir) do
			clean_command = "#{rake} nginx:clean --silent REALLY_QUIET=1"
			if !system(clean_command)
				STDERR.puts
				STDERR.puts "*** Command failed: #{clean_command}"
				exit 1
			end
			run_rake_task!("nginx") do |progress, total|
				yield(progress, total, 2, "Compiling Phusion Passenger...")
			end
		end
	end
	
	def install_nginx(source_dir)
		Dir.chdir(source_dir) do
			command = "./configure '--prefix=#{@nginx_dir}' --without-pcre " <<
				"--without-http_rewrite_module " <<
				"--without-http_fastcgi_module " <<
				"'--add-module=#{PASSENGER_ROOT}/ext/nginx'"
			run_command_with_throbber(command, "Preparing Nginx...") do |status_text|
				yield(0, 1, status_text)
			end
			
			backlog = ""
			total_lines = `make --dry-run`.split("\n").size
			IO.popen("make 2>&1", "r") do |io|
				progress = 1
				while !io.eof?
					line = io.readline
					backlog << line
					yield(progress, total_lines, "Compiling Nginx core...")
					progress += 1
				end
			end
			if $?.exitstatus != 0
				STDERR.puts
				STDERR.puts "*** ERROR: unable to compile Nginx."
				STDERR.puts backlog
				exit 1
			end
			
			command = "make install"
			run_command_with_throbber(command, "Copying files...") do |status_text|
				yield(1, 1, status_text)
			end
		end
	end
end

end # module PhusionPassenger

Thread.abort_on_exception = true
PhusionPassenger::Multicorn.run_command(ARGV)