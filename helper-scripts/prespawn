#!/usr/bin/env ruby
#  Phusion Passenger - https://www.phusionpassenger.com/
#  Copyright (c) 2010, 2011 Phusion
#
#  "Phusion Passenger" is a trademark of Hongli Lai & Ninh Bui.
#
#  See LICENSE file for license information.

STDOUT.sync = true
STDERR.sync = true

require 'uri'
require 'socket'
require 'timeout'

class PrespawnLocation
	class InvalidURLError < RuntimeError
		def initialize(url)
			@url = url
		end

		def to_s
			message
		end

		def message
			"'#{@url}' is not a valid URL."
		end
	end

	def self.parse(url)
		uri = uri_for(url)

		location = if uri.host == 'unix'
			UNIXPrespawnLocation.new(uri)
		else
			case uri.scheme
				when 'http'
					TCPPrespawnLocation.new(uri)
				when 'https'
					SSLPrespawnLocation.new(uri)
			end
		end

		unless location
			raise InvalidURLError, url
		end

		location
	end

	def self.uri_for(url)
		URI.parse(url)
	rescue URI::InvalidURIError
		raise InvalidURLError, url
	end

	def initialize(uri)
		@uri = uri
	end

	def request_path
		@uri.path.empty? ? '/' : @uri.path
	end

	def request_host
		@uri.host
	end

	def socket
		@socket ||= connect
	end

	def head_request
		socket.write("HEAD #{request_path} HTTP/1.1\r\n")
		socket.write("Host: #{request_host}\r\n")
		socket.write("Connection: close\r\n")
		socket.write("\r\n")

		begin
			Timeout.timeout(10) do
				socket.read
			end
		rescue Timeout::Error
		end
	end
end

class TCPPrespawnLocation < PrespawnLocation
	def request_port
		@uri.port
	end

	def connect
		TCPSocket.new('127.0.0.1', request_port)
	rescue Errno::ECONNREFUSED
		TCPSocket.new('::1', request_port)
	end
end

class SSLPrespawnLocation < TCPPrespawnLocation
	def connect
		require 'openssl'
		socket = OpenSSL::SSL::SSLSocket.new(super)
		socket.sync_close = true
		socket.connect
		socket
	end
end

class UNIXPrespawnLocation < PrespawnLocation
	def request_path
		super.split(':', 2).last
	end

	def request_host
		'_'
	end

	def socket_path
		@uri.path.split(':', 2).first
	end

	def connect
		UNIXSocket.new(socket_path)
	end
end

url = ARGV[0]
begin
	prespawn_location = PrespawnLocation.parse(url)
rescue PrespawnLocation::InvalidURLError => e
	STDERR.puts "*** ERROR: #{e}"
	exit 1
end

prespawn_location.head_request
