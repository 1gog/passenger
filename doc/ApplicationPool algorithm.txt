= ApplicationPool algorithm


== Introduction

For efficiency reasons, Passenger keeps a pool spawned Rails/Ruby applications.
Please read the C++ API documentation for the ApplicationPool class for a full
introduction. This document describes an algorithm for managing the pool, in a
high-level way.

The algorithm should strive to keep spawning to a minimum.


== Definitions

=== Vocabulary

- "Application root":
  The toplevel directory in which an application is contained. For Rails
  application, this is the same as RAILS_ROOT, i.e. the directory that contains
  "app/", "public/", etc. For a Rack application, this is the directory that
  contains "config.ru".

- "Active application process":
  An application process that has more than 0 sessions.

=== Types

Most of the types that we use in this document are pretty standard. But we
explicitly define some special types:

- list<SomeType>
  A doubly linked list which contains elements of type SomeType. It supports
  all the usual list operations that one can expect from a linked list, like
  add_to_back(), etc.
  
  We assume that operations that insert an element into the list return an
  iterator object. An iterator object is an opaque object which represents a
  specific position in the list; it probably contains the links to the previous
  and the next iterator, as well as a reference to the actual list element,
  depending on the list implementation.
  
  The following operations deserve special mention:
  * remove(iterator)
    Removes the specified element from the list, as represented by the given
    iterator. This operation can be done in O(1) time.
  
  * move_to_front(iterator)
    Moves the specified element - as represented by the given iterator - to
    the front of the list. This operation can be done in O(1) time.
  
- Group
  A compound type (class) which contains information about an application root,
  such as the application processes that have been spawned for this application
  root.
  
  A Group has the following members:
  * processes (list<ProcessInfo>) - a list of ProcessInfo objects.
    
    Invariant:
        processes is non-empty.
        for all 0 <= i < processes.size() - 1:
           if processes[i].process is active:
              processes[i + 1].process is active

  * size (unsigned integer): The number of items in _processes_.
  
  * max_requests (unsigned integer): The maximum number of requests that each
    application process in this group may process. After having processed this
    many requests, the application process will be shut down.
    A value of 0 indicates that there is no maximum.

- ProcessInfo
  A compound type (class) which contains a reference to an application process
  object, as well as various metadata, such as iterators for various linked
  lists. These iterators make it possible to perform actions on the linked
  lists in O(1) time.
  
  A ProcessInfo has the following members:
  * process - A process object, representing an application process.
  * start_time (time) - The time at which this application instance was
    started. It's set to the current time by ProcessInfo's constructor.
  * processed_requests (integer) - The number of requests processed by this
    application instance so far.
  * last_used (time) - The last time a session for this application process
    was opened or closed.
  * sessions (integer) - The number of open sessions for this application
    process.
    Invariant:
       (sessions == 0) == (This ProcessInfo is in inactive_apps.)
  * iterator - The iterator for this ProcessInfo in the linked list
    groups[process.app_root].processes
  * ia_iterator - The iterator for this ProcessInfo in the linked list
    inactive_apps. This iterator is only valid if this ProcessInfo really is
    in that list.

- PoolOptions
  A structure containing additional information used by the spawn manager's
  spawning process, as well as by the get() function.
  
  A PoolOptions has at least the following members:
  * max_requests (unsigned integer) - The maximum number of requests that the
    application process may process. After having processed this many requests,
    the application process will be shut down. A value of 0 indicates that there
    is no maximum.
  * use_global_queue (boolean) - Whether to use a global queue for all
    application processes, or a queue that's private to the application process.
    The users guide explains this feature in more detail.
  * restart_dir (string) - The directory in which the algorithm should look for
    restart.txt and always_restart.txt. The existance and modification times of
    these files tell the algorithm whether an application should be restarted.

=== Special functions

- spawn(app_root)
  Spawns a new application process at the given application root.
  Throws an exception if something went wrong. This function is thread-safe.
  Note that application process initialization can take an arbitrary amount
  of time.

=== Instance variables

The algorithm requires the following instance variables for storing state
information:

- lock: mutex
  This lock is used for implementing thread-safetiness. We assume that it
  is non-recursive, i.e. if a thread locks a mutex that it has already locked,
  then it will result in a deadlock.

- groups: map[string => Group]
  Maps an application root to its Group object. This map contains all
  application processes in the pool.
  
  Invariant:
     for all values g in groups:
        g.size <= count
     (sum of all g.size in groups) == count
  
- max: integer
  The maximum number of ProcessInfo objects that may exist in the pool.

- max_per_app: integer
  The maximum number of ProcessInfo objects that may be simultaneously alive
  for a single Group.

- count: integer
  The current number of ProcessInfo objects in the pool.
  Since 'max' can be set dynamically during the life time of an application
  pool, 'count > max' is possible.

- active: integer
  The number of application processes in the pool that are active.
  Invariant:
     active <= count

- inactive_apps: list<ProcessInfo>
  A linked list of ProcessInfo objects. All application processes in this list
  are inactive.
  
  Invariant:
     inactive_apps.size() == count - active
     for all x in inactive_apps:
        x can be found in _groups_.
        x.sessions == 0

- waiting_on_global_queue: integer
  If global queuing mode is enabled, then when get() is waiting for a backend
  process to become idle, this variable will be incremented. When get() is done
  waiting, this variable will be decremented.


== Class relations

Here's an UML diagram in ASCII art:

[ProcessInfo] 1..* --------+
                           |
                           |
                           
                           1
[ApplicationPool]       [Group]
       1                  0..*

       |                   |
       +-------------------+


== Algorithm in pseudo code

# Thread-safetiness notes:
# - All wait commands are to unlock the lock during waiting.

# Connect to an existing application process, or spawn a new application process
# and connect to that if necessary.
# 'app_root' refers to an application root.
# 'options' is an object of type 'PoolOptions', which contains additional
# information which may be relevant for spawning.
function get(app_root, options):
	MAX_ATTEMPTS = 10
	attempt = 0
	lock.synchronize:
		while (true):
			attempt++
			process_info, group = spawn_or_use_existing(app_root, options)
			process_info.last_used = current_time()
			process_info.sessions++
			try:
				return process_info.process.connect()
			on exception:
				# The app process seems to have crashed.
				# So we remove this process from our data
				# structures.
				process_info.sessions--
				processes = group.processes
				processes.remove(process_info.iterator)
				group.size--
				if processes.empty():
					groups.remove(app_root)
				count--
				active--
				if (attempt == MAX_ATTEMPTS):
					propagate exception


# Returns a pair of [ProcessInfo, Group] that matches the given application
# root. This function spawns a new process if necessary. All exceptions that
# occur are propagated.
function spawn_or_use_existing(app_root, options):
	group = groups[app_root]
	
	if needs_restart(app_root, options):
		if (group != nil):
			for all process_info in group.processes:
				if (process_info.sessions == 0):
					inactive_apps.remove(process_info.ia_iterator)
				else:
					active--
				group.processes.remove(process_info.iterator)
				count--
			groups.remove(app_root)
		Tell spawn server to reload code for app_root.
		group = nil
	
	if group != nil:
		# There are existing processes for this app root.
		processes = group.processes
		
		if (processes.front.sessions == 0):
			# There is an inactive process, so we use it.
			process_info = processes.front
			processes.move_to_back(process_info.iterator)
			inactive_apps.remove(process_info.ia_iterator)
			active++
		else if	(count >= max) or (
			(max_per_app != 0) and (group.size >= max_per_app)
			):
			# All processes are active, and the pool is full. 
			#  -OR-
			# All processes are active and the maximum number of
			# allowed processes for this application group has
			# been reached.
			#
			# We're not allowed to spawn a new application process.
			if options.use_global_queue:
				# So we wait until _active_ has changed, then
				# we restart this function and try again.
				waiting_on_global_queue++
				wait until _active_ has changed
				waiting_on_global_queue--
				goto beginning of function
			else:
				# So we connect to an already active process.
				# This connection will be put into that
				# process's private queue.
				process_info = an element in _processes_ with the smallest _session_ value
				processes.move_to_back(process_info.iterator)
		else:
			# All processes are active, but the pool hasn't reached its
			# maximum yet. So we spawn a new process.
			process_info = new ProcessInfo
			# TODO: we should add some kind of timeout check for spawning.
			process_info.process = spawn(app_root)
			process_info.sessions = 0
			iterator = processes.add_to_back(process_info)
			process_info.iterator = iterator
			group.size++
			count++
			active++
	else:
		# There are no processes for this app root.
		if (active >= max):
			# Looks like the pool is full and all processes are busy.
			# We wait until there's at least 1 idle process, or until
			# there's an empty slot in the pool, then restart this
			# function.
			wait until _active_ has changed
			goto beginning of function
		elsif count == max:
			# The pool is full, and not all processes are busy, but
			# we're in a though situation nevertheless: there are
			# several processes which are inactive, and none of them
			# have application root _app_root_, so we must kill one
			# of them in order to free a spot in the pool. But which
			# one do we kill? We want to minimize spawning.
			#
			# It's probably a good idea to keep some kind of
			# statistics in order to decide this. We want the
			# application root that gets the least traffic to be
			# killed. But for now, we kill a random application
			# process.
			process_info = inactive_apps.pop_front
			group = groups[process_info.app.app_root]
			processes = group.processes
			processes.remove(process_info.iterator)
			if processes.empty():
				groups.remove(process_info.process.app_root)
			else:
				group.size--
			count--
		process_info = new ProcessInfo
		# TODO: we should add some kind of timeout check for spawning.
		process_info.app = spawn(app_root)
		group = new Group
		group.size = 1
		group.max_requests = options.max_requests
		groups[app_root] = group
		iterator = group.processes.add_to_back(process_info)
		process_info.iterator = iterator
		count++
		active++
	return [process_info, group]


# The following function is to be called when a session has been closed.
# _process_info_ is the ProcessInfo that belongs to the process whose
# session has been closed.
function session_has_been_closed(process_info):
	lock.synchronize:
		group = groups[process_info.process.app_root]
		if group != nil:
			processes = group.processes
			process_info.processed++
			
			if (group.max_requests) > 0 and (process_info.processed >= group.max_requests):
				# The application process has processed its maximum allowed
				# number of requests, so we shut it down.
				processes.remove(process_info.iterator)
				group.size--
				if processes.empty():
					groups.remove(app_root)
				count--
				active--
			else:
				process_info.last_used = current_time()
				process_info.sessions--
				process_info.processed++
				if process_info.sessions == 0:
					processes.move_to_front(process_info.iterator)
					process_info.ia_iterator = inactive_apps.add_to_back(process_info.process)
					active--


function needs_restart(app_root, options):
	if (options.restart_dir is not set):
		restart_dir = app_root + "/tmp"
	else if (options.restart_dir is an absolute path):
		restart_dir = options.restart_dir
	else:
		restart_dir = app_root + "/" + options.restart_dir
	
	return (file_exists("$restart_dir/always_restart.txt")) or
	       (we haven't seen "$restart_dir/restart.txt" before) or
	       ("$restart_dir/restart.txt" changed since the last time we checked)


# The following thread will be responsible for cleaning up idle application
# process, i.e. processes that haven't been used for a while.
# This can be disabled per app when setting it's maxIdleTime to 0.
thread cleaner:
	lock.synchronize:
		done = false
		while !done:
			Wait until CLEAN_INTERVAL seconds have expired, or until the thread has been signalled to quit.
			if thread has been signalled to quit:
				done = true
				break
			
			now = current_time()
			for all process_info in inactive_apps:
				process = process_info.process
				group = groups[process.app_root]
				processes = group.processes
				# If MAX_IDLE_TIME is 0 we don't clean up the process,
				# giving us the option to persist the process
				# forever unless it's killed by another process.
				if (MAX_IDLE_TIME > 0) and (now - process_info.last_used > MAX_IDLE_TIME):
					processes.remove(process_info.iterator)
					inactive_apps.remove(process_info.ia_iterator)
					group.size--
					count--
				if processes.empty():
					groups.remove(process.app_root)

